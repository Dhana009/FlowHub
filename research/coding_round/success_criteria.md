# SDET Coding Round - Success Criteria

## If You Can Do These, You're Interview-Ready

### Framework Design Mastery

- ✅ Write a complete Page Object Model for a multi-page web application without guidance
- ✅ Design a test framework from scratch that handles multiple browsers and environments
- ✅ Create a framework that supports both UI and API testing with shared utilities
- ✅ Build a framework that can run tests across Chrome, Firefox, and Safari with minimal code duplication
- ✅ Design framework architecture decisions and explain trade-offs
- ✅ Handle 1000 test cases with your framework design
- ✅ Explain how framework handles application UI structure changes

### Test Automation Logic

- ✅ Write a test that validates a multi-step checkout flow with dynamic pricing and inventory checks
- ✅ Automate a login flow that includes CAPTCHA handling, 2FA, and session management
- ✅ Create tests for a real-time data dashboard that updates every 5 seconds
- ✅ Handle dynamic waits, stale element exceptions, and timing issues in automation
- ✅ Write tests that handle dynamic element IDs that change on every page load
- ✅ Create solution for testing application with inconsistent load times (2-30 seconds)
- ✅ Write tests for application requiring specific browser cookies or local storage state

### API Testing

- ✅ Write tests for a REST API that validate status codes, response schema, and data consistency across endpoints
- ✅ Test an OAuth 2.0 authentication flow including token refresh and expiration
- ✅ Validate API responses against a JSON schema and handle pagination
- ✅ Write API tests that validate status codes, response schema, and data integrity
- ✅ Handle API authentication and authorization
- ✅ Test API error scenarios and edge cases

### Data-Driven Testing

- ✅ Write parameterized tests that read test data from a CSV/JSON file and execute multiple scenarios
- ✅ Create a test that validates form validation with 50+ different input combinations
- ✅ Parameterize tests using data-driven approaches (CSV, JSON, database)
- ✅ Manage test data isolation and cleanup
- ✅ Design data-driven test architecture

### Database Testing

- ✅ Write SQL queries to set up and verify test data
- ✅ Handle database connections in test framework
- ✅ Manage transactions in test context
- ✅ Query database for test data validation

### Code Quality & Refactoring

- ✅ Refactor poorly written test code into maintainable, reusable components
- ✅ Explain your code design decisions and trade-offs during live coding
- ✅ Optimize test suite that takes 45 minutes to run
- ✅ Write maintainable, scalable test code (not just working code)
- ✅ Apply design patterns appropriately in test context
- ✅ Write clean, readable, professional code

### Problem-Solving & Debugging

- ✅ Debug failing tests and identify root causes (application vs. test framework issues)
- ✅ Differentiate between test failure and automation issue
- ✅ Handle real-world testing challenges (flaky tests, dynamic elements, timing)
- ✅ Solve problems under time pressure (60-90 minutes)
- ✅ Communicate design decisions clearly

### Python-Specific Coding (For Python Background)

- ✅ Parse log files and extract error messages with timestamps, group by error type
- ✅ Validate nested JSON API responses against schema, handle missing/null fields
- ✅ Generate unique test data (emails, usernames) with validation
- ✅ Read/merge multiple test result files and generate summary reports
- ✅ Parse test method names and extract parameters/categories
- ✅ Merge configuration dictionaries with precedence rules
- ✅ Implement thread-safe result collection from parallel workers
- ✅ Write retry utility with exponential backoff for flaky API calls
- ✅ Extract and validate emails from large text files efficiently
- ✅ Flatten nested dictionaries to environment variable format
- ✅ Compare test execution reports and identify differences
- ✅ Filter/sort test results by execution time with thresholds
- ✅ Deduplicate test data while preserving order
- ✅ Handle large files (10GB+) efficiently with memory considerations
- ✅ Use Python idioms (list/dict comprehensions, generators)
- ✅ Write code with proper error handling and edge cases
- ✅ Explain time/space complexity of solutions
- ✅ Use appropriate Python libraries (requests, json, re, threading)

### Integration & Scalability

- ✅ Run tests in parallel
- ✅ Manage test data in a CI/CD pipeline
- ✅ Design framework that supports 10,000 tests
- ✅ Integrate framework with CI/CD
- ✅ Handle cross-browser and cross-platform testing

## Readiness Indicators

**You're ready if you can:**
1. Design a complete test automation framework from scratch
2. Write Page Object Model for complex multi-page applications
3. Create API tests with comprehensive validation
4. Handle dynamic elements and timing issues
5. Parameterize tests with external data sources
6. Write SQL queries for test data management
7. Refactor code into maintainable components
8. Debug and identify root causes of failures
9. Explain design decisions and trade-offs
10. Solve problems under time pressure
11. Write professional, maintainable code
12. Handle scalability and parallel execution

## Evaluation Criteria Understanding

- **Correctness (40%)**: Code works and solves the problem
- **Code Quality & Design (30%)**: Maintainable, scalable, well-structured
- **Communication (20%)**: Can explain decisions and trade-offs
- **Efficiency (10%)**: Optimal solutions, performance considerations

